const cds = require('@sap/cds/lib'), { uuid } = cds.utils
const LOG = cds.log('mtx')

const DeploymentService = 'cds.xt.DeploymentService'
const Jobs = 'cds.xt.Jobs', Tasks = 'cds.xt.Tasks'

const t0 = cds.env.requires.multitenancy.t0 ?? 't0'

const {
  clusterSize = 1, workerSize = 1, poolSize = 1
} = cds.env.requires.multitenancy.jobs ?? cds.env.requires['cds.xt.SaasProvisioningService']?.jobs ?? {}

const RUNNING = 'RUNNING', FINISHED = 'FINISHED', FAILED = 'FAILED'

module.exports = class JobsService extends cds.ApplicationService { async init() {

  this.on('enqueue', async req => {
    const { tenants, op, args = [] } = req.data
    const _args = args.length > 0 ? ['with args', args.filter((arg) => !!arg)] : []
    LOG.info(`enqueuing '${op}' job for`, tenants, ..._args)

    const job_ID = req.data.ID ?? uuid()
    const job = req.job = { ID: job_ID, createdAt: new Date(), op }
    await cds.tx({ tenant: t0 }, tx => tx.run(INSERT.into(Jobs, job)))

    const enableClustering = tenants[0] instanceof Set
    const tasks = enableClustering
      ? tenants.map(cluster => Array.from(cluster).map(tenant => ({ job_ID, ID: uuid(), tenant, op })))
      : tenants.map(tenant => ({ job_ID, ID: uuid(), tenant, op }))
    const flatTasks = tasks.flat()

    await cds.tx({ tenant: t0 }, tx => tx.run(INSERT.into(Tasks, flatTasks)))

    const ds = await cds.connect.to(DeploymentService)
    const tx = ds.tx(req)

    _nextJob(tasks, task => tx[op](task.tenant, ...args), enableClustering) // start job, don't await

    req.http.res.set('Location', `${cds.server.url}/-/cds/jobs/pollJob(ID='${job_ID}')`)
    req.http.res.set('x-job-id', job_ID)
    req.http.res.status(202)
    // return { ...job, tasks: flatTasks.map(({ ID, tenant }) => ({ ID, tenant })) }
    return {
      ...job,
      tenants: Object.fromEntries(flatTasks.map(task => (
        [task.tenant, { ...task, job_ID: undefined, tenant: undefined, op: undefined }]
      )))
    }
  })

  this.on('pollJob', async req => {
    const job = await cds.tx({ tenant: t0 }, tx =>
      tx.run(SELECT.one.from(Jobs).where({ ID: req.data.ID }))
    )
    if (!job) cds.error(`No job found for ID ${req.data.ID}`, { status: 404 })
    return {
      status: job.status ?? job.STATUS,
      op: job.op ?? job.OP
    }
  })

  this.on('pollTask', req => {
    const task = cds.tx({ tenant: t0 }, tx =>
      tx.run(SELECT.one.from(Tasks).where({ ID: req.data.ID }))
    )
    return {
      status: task.status ?? task.STATUS,
      op: task.op ?? task.OP
    }
  })
}}

async function limiter(limit, payloads, fn, runSubtask = true) {
  const pending = [], all = []
  for (const payload of payloads) {
    const execute = Promise.resolve().then(() => runSubtask ? _nextTask(payload, fn(payload)) : fn(payload))
    all.push(execute)
    const executeAndRemove = execute.then(() => pending.splice(pending.indexOf(executeAndRemove), 1))
    pending.push(executeAndRemove)
    if (pending.length >= limit) {
      await Promise.race(pending)
    }
  }
  return Promise.allSettled(all)
}

async function _nextJob(tasks, fn, enableClustering = false) {
  if (enableClustering) {
    await limiter(clusterSize, tasks, tasks => limiter(workerSize ?? poolSize, Array.from(tasks), fn), false)
  } else {
    await limiter(workerSize ?? poolSize, tasks, fn)
  }

  const { job_ID } = tasks.flat()[0] // all tasks have the same job ID -> just take the first
  const one = await cds.tx({ tenant: t0 }, tx =>
    tx.run(SELECT.one.from(Tasks).where ({ job_ID, and: { status: RUNNING }}))
  )
  if (!one) {
    await cds.tx({ tenant: t0 }, tx =>
      tx.run(UPDATE(Jobs, { ID: job_ID }).with({ status: FINISHED }))
    )
  }
}

async function _nextTask(task, fn) {
  const { ID, tenant } = task
  let hasErrored = false
  try {
    cds.context = { tenant }
    return await fn
  } catch (e) {
    await cds.tx({ tenant: t0 }, tx =>
      tx.run(UPDATE(Tasks, { ID, tenant }).with({ status: FAILED }))
    )
    hasErrored = true
  } finally {
    if (!hasErrored) {
      await cds.tx({ tenant: t0 }, tx =>
        tx.run(UPDATE(Tasks, { ID, tenant }).with({ status: FINISHED }))
      )
    }
  }
}
