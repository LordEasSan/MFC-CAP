const cds = require('@sap/cds/lib'), {db} = cds.requires
const path = require('path')
module.exports = exports = { resources4, build, _imCreateParams }

if (db?.kind === 'hana') {

  // Check hana credentials to alert as early as possible
  if (!db.credentials?.sm_url) {
    cds.error('No HANA credentials found. Make sure the application is bound to a BTP Service Manager instance.')
  }

  exports.activated = 'HANA Database'

  // Add HANA-specific handlers to DeploymentService...
  cds.on ('served', () => {
    const { 'cds.xt.DeploymentService': ds } = cds.services
    const useOldIm = cds.env.requires['cds.xt.DeploymentService']?.['old-instance-manager']
    const hana = useOldIm ? require('./hana/inst-mgr') : require('./hana/srv-mgr')

    ds.on ('subscribe', req => {
      const { tenant:t, options: { _: params, csn } = {}, metadata } = req.data
      // REVISIT: in which scenarios do we need to get the tenant _before_ the subscription (e.g. shared service manager/domain concept)
      return prepareAndDeploy (t, hana.acquire(t, _imCreateParams(t, params, metadata)), params, csn ?? csn4(), undefined, csn ? undefined : resources4(t))
    })
    ds.on ('upgrade', async req => {
      const { tenant:t, options: { _: params } = {} } = req.data
      return prepareAndDeploy (t, hana.get(t), params, csn4(t), undefined, resources4(t))
    })
    ds.on ('extend', async req => {
      const { tenant:t, options: { _: params } = {}, csvs } = req.data
      return prepareAndDeploy (t, hana.get(t), params, csn4(t), csvs, resources4(t)) // we don't support extensions with own resources yet
    })
    ds.on ('deploy', async req => {
      const { tenant:t, options: { _: params, container, out } } = req.data
      return deploy (t, container, out, _hdiDeployParams(t, params))
    })
    ds.on ('unsubscribe', req => {
      const { tenant:t } = req.data
      if (cds.db) cds.db.disconnect(t) // Clean pool with active connections
      return hana.delete(t)
    })
    ds.on ('getTables', async req => {
      const { tenant:t } = req.data
      const { schema } = (t === _t0() ? await hana.acquire(t, _imCreateParams(t)) : await hana.get(t)).credentials
      const res = (await cds.tx({ tenant: t }, tx =>
        tx.run('SELECT TABLE_NAME FROM TABLES WHERE SCHEMA_NAME = ?', [schema])
      )).map(({ TABLE_NAME }) => TABLE_NAME)
      return res
    })
  })

}

function _t0() {
  return cds.env.requires.multitenancy.t0 ?? 't0'
}

function _imCreateParams(tenant, params = {}, metadata) {
  const paramsFromEnv = cds.env.requires['cds.xt.DeploymentService']?.hdi?.create ?? {}
  const paramsFromTenantOptions = cds.env.requires['cds.xt.DeploymentService']?.for?.[tenant]?.hdi?.create ?? {}

  const allParams = { ...paramsFromEnv, ...paramsFromTenantOptions, ...params?.hdi?.create }
  allParams.provisioning_parameters = { ..._encryptionParams(metadata), ...allParams.provisioning_parameters }
  return allParams
}

function _encryptionParams(data) {
  return data ? {
    subscriptionContext: {
      // crmId: '',
      globalAccountID: data.globalAccountGUID,
      subAccountID: data.subscribedSubaccountId,
      applicationName: data.subscriptionAppName
    }
  } : {}
}

function _hdiDeployParams(tenant, params = {}) {
  const paramsFromEnv = cds.env.requires['cds.xt.DeploymentService']?.hdi?.deploy || {}
  const paramsFromTenantOptions = cds.env.requires['cds.xt.DeploymentService']?.for?.[tenant]?.hdi?.deploy ?? {}
  return { ...paramsFromEnv, ...paramsFromTenantOptions, ...params?.hdi?.deploy }
}


const { fs, tar } = cds.utils
const LOG = cds.log('mtx')


async function csn4 (tenant) {
  const { 'cds.xt.ModelProviderService': mp } = cds.services
  return mp.getCsn ({ tenant, toggles: ['*'], activated: true }) // REVISIT: ['*'] should be the default?
}


async function resources4 (tenant) {

  const { 'cds.xt.ModelProviderService': mp } = cds.services
  const out = await fs.mkdirp ('gen',tenant)
  try {
    const rscs = await mp.getResources(true)
    await tar.xz(rscs).to(out)
    return out
  } catch (error) {
    // avoid that 404 bubbles up to response
    if (error.code) {
      error.code = 500
    }
    if (!error.message) {
      error.message = 'Could not get additional deployment resources'
    }
    cds.error(error)
  }
}

async function csvs4(tenant, csvs) {
  if (!csvs) return
  const csvOut = await fs.mkdirp ('gen', tenant, 'src', 'gen', 'data')
  for(let [e,src] of Object.entries(csvs)) {
    // store files in src/gen/data
    // TODO: this has to be reformated because it its changed in  push.js, line 27
    const file = e.split('').reverse().join('').replace('.', '-').split('').reverse().join('')
    await fs.promises.writeFile(path.join(csvOut, `${file}.csv`), src)
  }
}


async function build (csn, tenant, csvs) {
  const out = await fs.mkdirp ('gen',tenant,'src','gen'), gen = []
  for (const [ddl,{file}] of cds.compile.to.hdbtable(csn)) {
    gen.push (fs.write(ddl) .to (out,file))
  }

  // (re-) generate hdbtabledata files, only if new csvs have been added (extension)
  if (csvs) {
    const _tabledata4 = require('@sap/cds/bin/build/provider/hana/2tabledata')
    const tdata = await _tabledata4 (csn, { dirs: [path.join('gen',tenant,'src','gen','data')] });
    for (let [data, { file, csvFolder }] of tdata) {
      gen.push (fs.write(data) .to (csvFolder,file))
    }
  }

  return Promise.all (gen)
}


/** Arguments _hana, _csn and _resources are promises awaited inline below */
async function prepareAndDeploy (tenant, _hana, params, _csn, _extCsvs, ..._resources) {
  if (!cds.db) cds.db = cds.services.db = await cds.connect.to(db)

  const out = await fs.mkdirp ('gen',tenant)
  try {

    // Note: currently the hana files are created twice, first from getResources,
    // then from local compile -2 hana. This has to be adapted depending on if
    // the project is extended or not ideally the base hana files would have to
    // be filtered already when getting the resources

    // 1. unpack what comes from getResources()
    if (_resources) await Promise.all (_resources) //> has to finish before build

    // 1.5: csvs need to be resolved after all other resources have been resolved
    if (_extCsvs) await csvs4(tenant, _extCsvs)

    // 2. run cds compile -2 hana with potentially extended model from getCsn()
    const csn = await _csn
    if (csn) await build (csn,tenant,_extCsvs)

    if (tenant === _t0()) {
      await fs.write ({ "file_suffixes": {
        "csv":            { "plugin_name": "com.sap.hana.di.tabledata.source" },
        "hdbconstraint":  { "plugin_name": "com.sap.hana.di.constraint" },
        "hdbindex":       { "plugin_name": "com.sap.hana.di.index" },
        "hdbtable":       { "plugin_name": "com.sap.hana.di.table" },
        "hdbtabledata":   { "plugin_name": "com.sap.hana.di.tabledata" },
        "hdbview":        { "plugin_name": "com.sap.hana.di.view" }
      }}) .to (out,'src','gen','.hdiconfig')
    }

    // 3. hdi-deploy final build content
    const { 'cds.xt.DeploymentService': ds } = cds.services
    return await ds.deploy({ tenant, options: { container: await _hana, out, _: params } })
  } finally {
    await fs.rimraf (out) // REVISIT: keep that for caching later on
  }
}

async function deploy (tenant, container, out, options) {
  try {
    const useOldIm = cds.env.requires['cds.xt.DeploymentService']?.['old-instance-manager']
    const hana = useOldIm ? require('./hana/inst-mgr') : require('./hana/srv-mgr')
    await hana.deploy (container, tenant, out, options)
    LOG.info(`Successfully finished HANA deployment for tenant ${tenant}`)
  } finally {
    await fs.rimraf (out)
  }
}
