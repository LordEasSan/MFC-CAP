const path = require('path')
const mtxAdapter = require('./mtx-adapter')
const cds = require('@sap/cds')
const LOG = cds.log('mtx')
const { exists, fs: fsUtils  } = require('@sap/cds').utils
const fs = fsUtils.promises

module.exports._getExtensionProjectDirectory = async function(dir) {
    if (dir) {
        if (!exists(dir)) throw new Error(`Directory ${dir} does not exist.`)
        return dir
    } else {
        return await mtxAdapter.mkdirTemp()
    }
}

module.exports.migrate = async function migrate(tenants, directory, dry) {


    class MigrationResult {
        constructor() {
            this.connectedTenants = []
            this.results = {}
            this.hasError = false
        }

        addTenant(tenant) {
            this.connectedTenants.push(tenant)
            this.connectedTenants.push(mtxAdapter.getMetaTenantName(tenant))
        }

        log(tenant, message) {
            if (!this.results[tenant]) this.results[tenant] = []
            this.results[tenant].push(message)
            LOG.log(message)
        }

        error(tenant, message, error) {
            if (!this.results[tenant]) this.results[tenant] = []
            this.results[tenant].push(message)
            LOG.error(message, error)
            this.hasError = true
        }

        logResult() {
            LOG.log('Migration Result:')
            for (const tenant of Object.keys(this.results)) {
                for (const line of this.results[tenant]) LOG.log(`[${tenant}] ${line}`)
            }
        }
    }

    const migrationResult = new MigrationResult()

    let tenantsToMigrate = tenants

    // handle tenant "*" -> retrieve all tenants
    if (tenants.includes('*')) {
        tenantsToMigrate = await mtxAdapter.getAllTenantIds()
    }

    const t0 = cds.env.requires.multitenancy?.t0 ?? 't0'

    migrationResult.addTenant(t0)

    let extensibility = cds.env.requires.extensibility
    let projectsDir

    for (const tenant of tenantsToMigrate) {

        migrationResult.addTenant(tenant)

        // skip migration of t0
        if (tenant === t0) continue

        // check if tenant was already migrated
        const migrated = await mtxAdapter.isMigrated(tenant)
        if (migrated.timestamp) {
            migrationResult.log(tenant, `Tenant ${tenant} is already migrated. Skipping migration.`)
            continue
        }

        // Get from old mtx
        const metadata = await mtxAdapter.getMetadata(tenant)

        if (extensibility) {
            // disable extension deployment            
            const ds = await cds.connect.to('cds.xt.DeploymentService')
            ds.prepend (srv => srv.on ('extend', (req) => { }))

            // update tenant metadata + extension tables
            // add extension tables - TODO could also be done on-the-fly with push
            const extTables = await cds.load(`${__dirname}/../../db/extensions.cds`)
            cds.model = cds.db.model = cds.compile.for.nodejs(extTables)
            if (!dry) {
                try {
                    await cds.tx({ tenant}, tx => tx.run(SELECT.one(1).from('cds.xt.Extensions')))
                    //const one = await SELECT.one(1).from('cds.xt.Extensions')
                    // add metadata in case it had not been added before
                    await _addMetadata(tenant, metadata)
                } catch (error) {
                    LOG.log('cds.xt.Extensions not yet deployed, deploying ...')
                    LOG.debug(error)
                    await ds.subscribe({ tenant, metadata, options: { csn: extTables } }) // also creates metadata ...
                }
            }
            
            // run extend -> into memory?
            const mtxExtension = await mtxAdapter.getExtension(tenant)

            if (mtxExtension) {
                // TODO allow different folder from command line to preserve results
                projectsDir = projectsDir || await module.exports._getExtensionProjectDirectory(directory)
                const projectFolder = path.join(projectsDir, tenant)

                await _buildExtensionProject(projectFolder, mtxExtension)

                // Verify migrated extension
                try {
                    await _verifyExtension(projectFolder, tenant)
                    migrationResult.log(tenant, `Extension verification successful for tenant ${tenant}`)
                } catch (error) {
                    migrationResult.error(tenant, `Extension verification failed for tenant ${tenant}, skipping migration`, error)
                    continue
                }

                // upload extensions
                if (!dry) {
                    try {
                        const extensionTgz = await fs.readFile(path.join(projectFolder, 'gen', 'extension.tgz'))
                        const es = await cds.connect.to('cds.xt.ExtensibilityService')
                        await es.tx({ tenant, user: new cds.User.Privileged }, tx =>
                            tx.push(extensionTgz.toString('base64'), 'migrated')
                        )
                        migrationResult.log(tenant, `Extension for tenant ${tenant} added.`)
                    } catch (error) {
                        migrationResult.error(tenant, `Error pushing extension for tenant ${tenant}`, error)
                    }
                }
            }
        } else {
           if (!dry) {
             await _addMetadata(tenant, metadata)
             migrationResult.log(tenant, `Metadata for tenant ${tenant} added.`)
           }
        }

        // TODO store status in __META__ tenant? Or use t0-tenant metadata (not save, can be in intermediate state)?
        if (!dry) await mtxAdapter.setMigrated(tenant)
        migrationResult.log(tenant, `Migration of tenant ${tenant} done.`)
    }

    // cleanup tmpdir, keep directory if it was set externally
    if (!directory && projectsDir) await fs.rm(projectsDir, { recursive: true, force: true })

    // TODO check why process does not immediately terminate
    LOG.log('Extension migration done')
    return migrationResult
}

async function _addMetadata(tenant, metadata) {
    const t0 = cds.env.requires.multitenancy?.t0 ?? 't0'
    // TODO Upsert ?
    try {
        await cds.tx({ tenant: t0 }, tx =>
          tx.run(INSERT.into('cds.xt.Tenants', { ID: tenant, metadata: JSON.stringify(metadata) }))
        )
    } catch (e) {
        if (e.message !== 'ENTITY_ALREADY_EXISTS') throw e
    }
}

async function _verifyExtension(projectFolder, tenant) {

    let extensionCsn
    try {
        const extensionCsnString = await fs.readFile(path.join(projectFolder, 'gen', 'ext', 'extension.csn'))
        extensionCsn = JSON.parse(extensionCsnString)
    } catch (error) {
        // if migration gets here there MUST be an extension -> throw error
        throw new Error(`No extension build result found for tenant ${tenant}`)
    }

    // check diff and abort if necessary
    // Toggles? -> all
    const mp = await cds.connect.to('cds.xt.ModelProviderService')
    const isExtended = await (async () => { try { return await mp.isExtended(tenant) } catch(error) { return false } })()
    const mainCsn = await mp.getCsn({ tenant, flavor: 'inferred', activated: true })
    const previewCsn = isExtended ? mainCsn : (extensionCsn ? cds.extend(mainCsn).with(extensionCsn) : mainCsn)
    const existingCsn = await mtxAdapter.getCsn(tenant)

    const existingHana = cds.compiler.to.hdi.migration(existingCsn)
    const newHana = cds.compiler.to.hdi.migration(previewCsn)

    // are artifacts lost?
    const hanaDiffNewToOld = cds.compiler.to.hdi.migration(cds.minify(previewCsn), {}, cds.minify(existingHana.afterImage))
    if (hanaDiffNewToOld.deletions.length) {
        throw new Error(`Verification error for tenant ${tenant}: migrated model is missing artifacts:\n ${hanaDiffNewToOld.deletions.map( ({ name, suffix }) => `${name}${suffix}\n`)}`)
    }

    // does the new model contain more artifacts?
    const MTXS_ENTITIES = ['cds.xt.Extensions']
    const hanaDiffOldToNew = cds.compiler.to.hdi.migration(cds.minify(existingCsn), {}, cds.minify(newHana.afterImage)) // cds.xt.Extensions is allowed
    const filteredDeletions = hanaDiffOldToNew.deletions.filter( ({name}) => !MTXS_ENTITIES.includes(name))
    if (filteredDeletions.length) {
        throw new Error(`Verification error for tenant ${tenant}: migrated model has additional artifacts:\n ${hanaDiffOldToNew.deletions.map( ({ name, suffix }) => `${name}${suffix}\n`)}`)
    }
}

async function _buildExtensionProject(projectFolder, mtxExtension) {
    try {
        await fs.rm(projectFolder, { recursive: true, force: true })
    } catch (e) {
        // ignore 
    }
    await fs.mkdir(projectFolder)

    // mtxExtension is a map of files
    await mtxAdapter.writeFilesFromMap(Array.from(mtxExtension), projectFolder)

    // overwrite package.json
    await _writePackageJson(projectFolder, 'extension', '_base')

    // TODO avoid parallel execution !! - use runner from old mtx?
    const env = cds.env
    try {
        await cds.build({ project: projectFolder })
    } finally {
        cds.env = env
    }
}

async function _writePackageJson(dir, name, main) {
    // generate package.json
    const packageJson = {
        "name": name,
        "version": "1.0.0",
        "description": "Generated extension project",
        "cds": {
            "extends": main
        }
    }
    await fs.writeFile(path.join(dir, 'package.json'), JSON.stringify(packageJson, 2))
}