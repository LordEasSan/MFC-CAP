const cds = require('@sap/cds/lib')
const LOG = cds.log('mtx')
const SaasRegistryUtil = require('./saas-registry-util')
const DeploymentService = 'cds.xt.DeploymentService'
const Tenants = 'cds.xt.Tenants'
const JobsService = 'cds.xt.JobsService'

if (!cds.env.requires.multitenancy) cds.env.requires.multitenancy = true // we need to run in multitenancy mode for t0 ops
const { t0 = 't0' } = cds.env.requires.multitenancy

module.exports = class SaasProvisioningService extends cds.ApplicationService {

  async init() {
    // TODO: Support UPDATE event type for saas-registry
    //this.on('UPDATE', 'tenant', ({data}) => data?.eventType === 'UPDATE' ? this.update : this.create)
    this.on('UPDATE', 'tenant', this.create)
    this.on('READ', 'tenant', this.read)
    this.on('DELETE', 'tenant', this.delete)
    this.on('dependencies', this.getDependencies)
    this.on('getAppUrl', this.determineAppUrl)
    this.on('succeeded', this.succeeded)
    this.on('failed', this.failed)
    this.on('upgrade', this.update)
    this.on('upgradeAll', this.updateAll)

    await super.init() // ensure to call super.init()
  }

  _options(data) {
    if (!data?.options && !data._ && !data._application_) return undefined
    const _ = data._application_?.sap ? { hdi: { create: data._application_.sap['service-manager'] } } : data._
    return { ...data.options, _ }
  }

  async _tenantsByDb(tenants) {
    let tenantToDbUrl
    if (cds.requires.db.kind === 'hana') {
      const hana = require('../plugins/hana/srv-mgr')
      tenantToDbUrl = (await hana.getAll(tenants)).reduce((res, t) =>
        ({ ...res, [t.labels.tenant_id[0]]: `${t.credentials.host}:${t.credentials.port}` })
      , {})
    } else {
      tenantToDbUrl = tenants.reduce((res, t) => ({ ...res, [t]: cds.db.getDbUrl(t) }), {})
    }
    const dbToTenants = {}
    for (const tenant of tenants) {
      const dbUrl = tenantToDbUrl[tenant]
      if (!dbToTenants[dbUrl]) dbToTenants[dbUrl] = new Set
      dbToTenants[dbUrl].add(tenant)
    }
    return Object.values(dbToTenants)
  }

  async determineAppUrl(context) {
    return SaasRegistryUtil.getAppUrlFromHeaders(context.data.subscriptionHeaders)
        ?? SaasRegistryUtil.getAppUrlFromEnv(context.data.subscriptionPayload)
        ?? 'Tenant successfully subscribed - no application URL provided'
  }

  _getSubscribedTenant(context) {
    const { data, params } = context ?? {}
    const { subscribedTenantId } = data ?? {}
    return params?.[0]?.subscribedTenantId ?? subscribedTenantId
  }

  async create(context) {
    LOG.debug('Received subscription request', context.data)
    const { isSync } = SaasRegistryUtil.getCallbackUrlsFromHeaders(context.http?.req)
    const tenant = this._getSubscribedTenant(context)

    if (isSync) {
      LOG.info(`Subscribing tenant ${tenant}`)
      const sps = await cds.connect.to('cds.xt.SaasProvisioningService')
      const _appUrl = sps.getAppUrl(context.data, context.headers)
      try {
        const ds = await cds.connect.to(DeploymentService)
        const tx = ds.tx(context)
        await tx.subscribe(tenant, context.data, this._options(context.data))
        LOG.info(`Successfully subscribed tenant ${tenant}`)
        await this.emit('succeeded', { task: 'subscribe', result: await _appUrl })
      } catch (error) {
        await this.emit('failed', { task: 'subscribe', result: error })
        throw error
      }
      return _appUrl
    } else {
      const lcs = await cds.connect.to(JobsService)
      const tx = lcs.tx(context)
      return tx.enqueue([tenant], 'subscribe', [context.data, this._options(context.data)])
    }
  }

  async read(context) { // TODO check params for get
    const tenantId = this._getSubscribedTenant(context)
    if (tenantId) {
      const tenant = await cds.tx({ tenant: t0 }, tx =>
        tx.run(SELECT.one.from(Tenants, { ID: tenantId }, tenant => { tenant.metadata }))
      )
      if (!tenant) cds.error(`Tenant ${tenantId} not found`, { status: 404 })
      return JSON.parse(tenant.metadata)
    }
    return (await cds.tx({ tenant: t0 }, tx =>
      tx.run(SELECT.from(Tenants, tenant => { tenant.ID, tenant.metadata }))
    )).map(tenant => JSON.parse(tenant.metadata))
  }

  async update(context) {
    if (!context.data?.tenants?.length) return
    const tenantList = context.data.tenants.includes('*') ? undefined : context.data.tenants
    const tenants = tenantList ?? (await cds.tx({ tenant: t0 }, tx =>
      tx.run(SELECT.from(Tenants, tenant => { tenant.ID }))
    )).map(({ ID }) => ID)
    const { isSync } = SaasRegistryUtil.getCallbackUrlsFromHeaders(context.http?.req)
    const {
      clusterSize = 1, workerSize = 1, poolSize = 1
    } = cds.env.requires.multitenancy.jobs ?? cds.env.requires['cds.xt.SaasProvisioningService']?.jobs ?? {}
    const dbToTenants = clusterSize > 1 ? await this._tenantsByDb() : [new Set(tenants)]
    LOG.info('Upgrading tenants', tenants)
    if (isSync) {
      try {
        const ds = await cds.connect.to(DeploymentService)
        const tx = await ds.tx(context)
        await this.limiter(clusterSize, dbToTenants, tenants =>
          this.limiter(workerSize ?? poolSize, Array.from(tenants), t => tx.upgrade(t))
        )
        await this.emit('succeeded', { task: 'upgrade' })
      } catch (error) {
        await this.emit('failed', { task: 'upgrade', result: error })
        throw error
      }
    } else {
      const lcs = await cds.connect.to(JobsService)
      const tx = lcs.tx(context)
      return tx.enqueue(dbToTenants, 'upgrade')
    }
  }

  async delete(context) {
    LOG.debug('Received unsubscription request', context.data)
    const { isSync } = SaasRegistryUtil.getCallbackUrlsFromHeaders(context.http?.req)

    const tenant = this._getSubscribedTenant(context)
    LOG.info(`Unsubscribing tenant ${tenant}`)

    const one = await cds.tx({ tenant: t0 }, tx =>
      tx.run(SELECT.one.from(Tenants, { ID: tenant }, t => { t.metadata }))
    ) ?? {}
    const metadata = JSON.parse(one?.metadata ?? '{}')

    if (isSync) {
      const ds = await cds.connect.to(DeploymentService)
      const tx = ds.tx(context)
      try {
        await tx.unsubscribe(tenant, { metadata })
        await this.emit('succeeded', { task: 'unsubscribe' })
      } catch (error) {
        if (error.statusCode === 404) {
          LOG.info(`Tenant ${tenant} is currently not subscribed`)
        } else {
          await this.emit('failed', { task: 'unsubscribe', result: error })
          throw error
        }
      }
    } else {
      const lcs = await cds.connect.to(JobsService)
      const tx = lcs.tx(context)
      return tx.enqueue([tenant], 'unsubscribe', [{ metadata }])
    }
  }

  updateAll(context) {
    LOG.warn(`updateAll is deprecated. Use /-/cds/saas-provisioning/upgrade instead.`)
    if (!context.data?.tenants) context.data.tenants = ['*']
    return this.update(context)
  }

  getDependencies() {
    return cds.env.requires['cds.xt.SaasProvisioningService']?.dependencies?.map(d => ({ xsappname: d })) ?? []
  }

  async limiter(limit, payloads, fn) {
    const pending = [], all = []
    for (const payload of payloads) {
      const execute = Promise.resolve().then(() => fn(payload))
      all.push(execute)
      const executeAndRemove = execute.then(() => pending.splice(pending.indexOf(executeAndRemove), 1))
      pending.push(executeAndRemove)
      if (pending.length >= limit) {
        await Promise.race(pending)
      }
    }
    return Promise.allSettled(all)
  }

  async succeeded(event) {
    await this._sendCallback('SUCCEEDED', 'Succeeded', event.data.result)
  }

  async failed(event) {
    await this._sendCallback('FAILED', 'Failed', event.data.result)
  }

  async _sendCallback(status, message, subscriptionUrl) {
    const originalRequest = cds.context?._?.req
    const {
      isSync, isInternalCallback, saasCallbackUrlPath, callbackUrl, noCallback
    } = SaasRegistryUtil.getCallbackUrlsFromHeaders(originalRequest)
    if (!isSync && !noCallback) {
      /// TODO evaluate params for new rest adapter
      const tenant = this._getSubscribedTenant(originalRequest.body)
      const payload = { status, message, subscriptionUrl }

      // additional payload for internal callback (java)
      if (isInternalCallback) {
          Object.assign(payload, {
              saasRequestPayload: originalRequest.body,
              saasCallbackUrl: saasCallbackUrlPath
          })
      }
      LOG.debug(`Send callback to ${callbackUrl}`)
      try {
          await SaasRegistryUtil.sendResult(callbackUrl, tenant, payload)
      } catch (error) {
          LOG.error(error)
      }
    }
  }
}
